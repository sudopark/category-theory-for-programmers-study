## 8. Functoriality

ëª‡ê°œì§€ ì˜ˆë¥¼ í†µí•˜ì—¬ í‘í„°ê°€ ë¬´ì—‡ì¸ì§€ ì•Œì•„ë´¤ì—ˆìŠµë‹ˆë‹¤. ì´ì œ ì‘ì€ í‘í„°ë¡œ ë¶€í„° ë” í° í‘í„°ë¥¼ ì–´ë–»ê²Œ ë§Œë“œëŠ”ì§€ ì•Œì•„ë´…ì‹œë‹¤. íŠ¹ë³„íˆ ì–´ë–¤ íƒ€ì… ìƒì„±ì(ì¹´í…Œê³ ë¦¬ ëŒ€ìƒê°„ ë§¤í•‘ì— í•´ë‹¹í•˜ëŠ”)ê°€ í‘í„°(ì‚¬ìƒì˜ ë§¤í•‘ë„ í¬í•¨í•˜ëŠ”)ë¡œ í™•ì¥ ë  ìˆ˜ ìˆëŠ”ì§€ ë§ì…ë‹ˆë‹¤.



### 8.1 Bifunctors

í‘í„°ëŠ” Cat(ì¹´í…Œê³ ë¦¬ì˜ ì¹´í…Œê³ ë¦¬)ì—ì„œì˜ ì‚¬ìƒì´ê¸° ë•Œë¬¸ì— ì‚¬ìƒì— ëŒ€í•œ ë§ì€ ì§ê´€ë“¤ì´(íŠ¹íˆ í•¨ìˆ˜ì— ëŒ€í•œ) í‘í„° ìì²´ì—ë„ ì ìš©ë©ë‹ˆë‹¤. ì˜ˆë¥¼ë“¤ì–´ ë‘ê°œì˜ ì¸ìë¥¼ ë°›ëŠ” í•¨ìˆ˜ê°€ ìˆì„ë•Œ ë‘ ì¸ìì˜ í‘í„° í˜¹ì€ bifunctorë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëŒ€ìƒì—ê²Œ  ë°”ì´í‘í„°ëŠ” ëª¨ë“  ìŒì˜ ëŒ€ìƒ(í•˜ë‚˜ëŠ” ì¹´í…Œê³ ë¦¬ Cì—ì„œ, ë‹¤ë¥¸ í•˜ë‚˜ëŠ” ì¹´í…Œê³ ë¦¬ D ì—ì„œ)ì„ ì¹´í…Œê³ ë¦¬ Eì˜ ì–´ë–¤ ëŒ€ìƒìœ¼ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤. ì´ê²ƒì€ ì¹´í…Œê³ ë¦¬ì˜ Cartesian product C x D ì—ì„œ Eë¡œì˜ ë§¤í•‘ ì…ë‹ˆë‹¤.

![](https://bartoszmilewski.files.wordpress.com/2015/01/bifunctor.jpg?w=300&h=286)

ì´ê²ƒì€ ë§¤ìš° ì§ê´€ì  ì…ë‹ˆë‹¤. í•˜ì§€ë§Œ í‘í„°ì  ì„±ì§ˆ(functoriality)ì€ ë°”ì´í‘í„°ê°€ ì‚¬ìƒë„ ë§¤í•‘í•´ì•¼í•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì´ê²½ìš°ì— ë§ˆì°¬ê°€ì§€ë¡œ ë‘ê°œì˜ ì‚¬ìƒ(ê° ì¹´í…Œê³ ë¦¬ C, Dì—ì„œ)ì„ ì¹´í…Œê³ ë¦¬ Eì˜ íŠ¹ì • ì‚¬ìƒìœ¼ë¡œ ë§¤í•‘ë§ì…ë‹ˆë‹¤.

ë‹¤ì‹œë§í•˜ì§€ë§Œ ë‘ ì‚¬ìƒì˜ ìŒì€ CxD product ì¹´í…Œê³ ë¦¬ì—ì„œ E ì¹´í…Œê³ ë¦¬ê¹Œì§€ í•˜ë‚˜ì˜ ì‚¬ìƒ ì´ë¼ëŠ” ì  ì…ë‹ˆë‹¤. ë²”ì£¼ì˜ cartesian productì—ì„œ ì‚¬ìƒì„ í•œìŒì˜ ì‚¬ìƒìœ¼ë¡œ ì •ì˜í•©ë‹ˆë‹¤. - í•œ ìŒì˜ ëŒ€ìƒì—ì„œ ë‹¤ë¥¸ ìŒì˜ ëŒ€ìƒìœ¼ë¡œ ê°€ëŠ”. ì´ ì‚¬ìƒ ìŒì€ ì•„ë˜ì™€ê°™ì´ í•©ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```haskell
(f, g) . (f', g') = (f.f', g.g')
```

í•©ì„±ì€ ê²°í•©ë²•ì¹™ì„ ë§Œì¡±í•˜ê³  identityë„ ì§€ë‹ˆê³  ìˆìŠµë‹ˆë‹¤. (Identity ì‚¬ìƒì˜ í˜ì–´ëŠ” (id, id)ì´ê¸° ë•Œë¬¸ì—). ê·¸ëŸ¬ê¸° ë•Œë¬¸ì— ì¹´í…Œê³ ë¦¬ì˜ Cartesian productëŠ” ì§„ì • ì¹´í…Œê³ ë¦¬ ì…ë‹ˆë‹¤.

ë°”ì´í‘í„°ë¥¼ ë” ì‰½ê²Œ ìƒê°í•˜ëŠ” ë°©ë²•ì€ ê° ì•„ê·œë¨¼íŠ¸ì— ë”°ë¼ì„œ ë‹¤ë¥´ê²Œ í‘í„°ë¥¼ ê³ ë ¤í•˜ëŠ” ê²ƒ ì…ë‹ˆë‹¤. ê·¸ë ‡ê¸° ë•Œë¬¸ì— functorial lawsë¥¼(ê²°í•©ë²•ì¹™ê³¼ identity ë³´ì¡´) í‘í„°ì—ì„œ ë°”ì´í‘í„°ë¡œ ë³€í™˜í•˜ëŠ” ëŒ€ì‹ ì— ê° ì•„ê·œë¨¼íŠ¸ì— ë³„ë¡œ ë”°ë¡œ ì²´í¬í•˜ëŠ” ê²ƒë§Œìœ¼ë¡œë„ ì¶©ë¶„í•©ë‹ˆë‹¤. (í•˜ì§€ë§Œ ì¼ë°˜ì ìœ¼ë¡œ ë¶„ë¦¬ëœ funtorialityëŠ” joint functorialityë¥¼ ì¦ëª…í•˜ëŠ”ê²ƒì—ëŠ” ì¶©ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Joint functorialityê°€ ì‹¤íŒ¨í•˜ëŠ” ì¹´í…Œê³ ë¦¬ëŠ” premonoidalì´ë¼ ë¶ˆë¦½ë‹ˆë‹¤.)

í•˜ìŠ¤ì¼ˆì—ì„œ ë°”ì´í‘í„°ë¥¼ ì •ì˜í•´ ë´…ì‹œë‹¤. ì´ê²½ìš°ì— ë‚˜ì˜¤ëŠ” 3ê°€ì§€ ì¹´í…Œê³ ë¦¬ëŠ” ëª¨ë‘ í•˜ìŠ¤ì¼ˆ íƒ€ì…ì˜ ì¹´í…Œê³ ë¦¬ ì…ë‹ˆë‹¤. ë°”ì´í‘í„°ëŠ” ë‘ê°€ì§€ íƒ€ì…ì„ ë°›ëŠ” íƒ€ì… ìƒì„±ì ì…ë‹ˆë‹¤. ë‹¤ìŒì€ Control ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ê°€ì ¸ì˜¨ ë°”ì´í‘í„° íƒ€ì… í´ë˜ìŠ¤ì˜ ì •ì˜ ì…ë‹ˆë‹¤.

```haskell
class Bifunctor f where
	bimap :: (a -> c) -> (b -> d) -> f a b -> f c d
	bimap g h = first g . second h
	first :: (a -> c) -> f a b -> f c b
	first g = bimap g id
	second :: (b -> d) -> f a b -> f a d
	second = bimap id
```

![bimap](https://bartoszmilewski.files.wordpress.com/2015/01/bimap.jpg)

íƒ€ì… ë³€ìˆ˜ fëŠ” ë°”ì´í‘í„°ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ëª¨ë“  íƒ€ì…ì˜ ì‹œê·¸ë‹ˆì²˜ì—ì„œ í•­ìƒ ë‘ íƒ€ì… ì¸ìˆ˜ì— ì ìš©ë¨ì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì²«ë²ˆì¨° íƒ€ì… ì‹œê·¸ë‹ˆì²˜ëŠ” ë‘ í•¨ìˆ˜ë¥¼ ë™ì‹œì— ë§¤í•‘í•˜ëŠ” ê²ƒìœ¼ë¡œ bimapì„ ì •ì˜í•©ë‹ˆë‹¤. ê²°ê³¼ëŠ” ë°”ì´í‘í„°ì˜ íƒ€ì… ìƒì„±ìì— ì˜í•´ ë§Œë“¤ì–´ì§„ íƒ€ì…ì— ì‘ë™í•˜ëŠ” ë¦¬í”„íŒ…ëœ í•¨ìˆ˜ì…ë‹ˆë‹¤.( f a b -> f c d). first, secondë¼ëŠ” ì¸¡ë©´ìœ¼ë¡œ bimapì´ ê¸°ë³¸êµ¬í˜„ ë˜ì–´ ìˆìŠµë‹ˆë‹¤.(ìœ„ì—ì„œ ì–¸ê¸‰í–ˆë“¯ì´ ì´ê²ƒì€ ì–¸ì œë‚˜ ì ìš©ë˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤. first g . second hëŠ”second h . first gì™€ í•­ìƒ ê°™ì§€ëŠ” ì•Šê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.)

ë‘ê°œì˜ ë‹¤ë¥¸ íƒ€ì… ì‹œê·¸ë‹ˆì²˜ first, secondëŠ” ê°ê° ì²«ë²ˆì¨°, ë‘ë²ˆì¨° ì¸ìˆ˜ì— ëŒ€í•œ fì˜ í‘í„°ì  ì„±ì§ˆì„ í™•ì¸í•´ì£¼ëŠ” fmap ì…ë‹ˆë‹¤.

![](https://bartoszmilewski.files.wordpress.com/2015/01/first.jpg?w=150&h=124)![](https://bartoszmilewski.files.wordpress.com/2015/01/second.jpg?w=150&h=138)

(ì¢Œì¸¡: first, ìš°ì¸¡: second )

íƒ€ì… í´ë˜ìŠ¤ì˜ ì •ì˜ëŠ” bimap ì¸¡ë©´ì—ì„œ ë‘ê°€ì§€ ê¸°ë³¸ êµ¬í˜„ì„ ì œê³µí•©ë‹ˆë‹¤.

Bufunctorì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì„ ì–¸í• ë–„, bimap êµ¬í˜„í•˜ê³  first, secondì˜ ê¸°ë³¸êµ¬í˜„ì„ ì‚¬ìš©í•˜ê±°ë‚˜ first, secondë¥¼ êµ¬í˜„í•˜ê³  bimapì˜ ë””í´íŠ¸ êµ¬í˜„ì„ ì‚¬ìš©í•˜ë˜ê°€ í•´ì•¼í•©ë‹ˆë‹¤.(ë¬¼ë¡  ì´ 3ê°€ì§€ ëª¨ë‘ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.)

### 8.2 Product and Coproduct Bifunctors

ë°”ì´í‘í„°ì˜ ì¤‘ìš”í•œ ì˜ˆëŠ” ì¹´í…Œê³ ë¦¬ì ì¸ product ì…ë‹ˆë‹¤. (universal constructionì— ì˜í•´ ì •ì˜ëœ ë‘ ëŒ€ìƒê°„ì˜ product) ë§Œì¼ ì–´ë–¤ ëŒ€ìƒì˜ ìŒì—ì„œë“  productì´ ì¡´ì¬í•œë‹¤ë©´ ì´ ëŒ€ìƒë“¤ë¡œ ë¶€í„° ê³± ê¹Œì§€ì˜ ë§¤í•‘ì€ bifunctorial ì…ë‹ˆë‹¤. ì´ëŠ” ë³´í¸ì  ê·¸ë¦¬ê³  íŠ¹ë³„íˆ í•˜ìŠ¤ì¼ˆì—ì„œ ì°¸ ì…ë‹ˆë‹¤. ë‹¤ìŒì€ ê°€ì¥ ë‹¨ìˆœí•œ product íƒ€ì… pair ìƒì„±ìì— ëŒ€í•œ Bifunctor ì¸ìŠ¤í„´ìŠ¤ ì…ë‹ˆë‹¤.

```haskell
instance Bifunctor (,) where
	bimap f g (x, y) = (f x, g y)
	-- bimapì´ ë‹¨ìˆœí•˜ê²Œ ì²«ë²ˆì¨° í•¨ìˆ˜ë¥¼ pairì˜ ì²«ë²ˆì¨° ì¸ìì—, ë‘ë²ˆì¨° í•¨ìˆ˜ë¥¼ pairì˜ ë‘ë²ˆì§¸ ì¸ìì— ì ìš©í•©ë‹ˆë‹¤.
	-- bimap :: (a -> c) -> (b -> d) -> (a, b) -> (c, d)
	-- f :: (a -> c), g :: (b -> d) ì´ bmapì— ì˜í•˜ì—¬ ìŒìœ¼ë¡œ ë³€í™˜
```

ìŒëŒ€ì„±ì— ì˜í•˜ì—¬ ì¹´í…Œê³ ë¦¬ì—ì„œ ì–´ë–¤ ëŒ€ìƒ ìŒì— ëŒ€í•˜ì—¬ coproductê°€ ì •ì˜ëœë‹¤ë©´ ì´ê²ƒë˜í•œ bifunctor ì…ë‹ˆë‹¤.í•˜ìŠ¤ì¼ˆì—ì„œ Bifunctorì˜ ì¸ìŠ¤í„´ìŠ¤ì¸ Either íƒ€ì… ìƒì„±ìë¥¼ ì´ìš©í•˜ì—¬ ì˜ˆë¥¼ ë“¤ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```haskell
instance Bifunctor Either where
	bimap f _ (Left x) = Left (f x)
	bimap _ g (Right y) = Right (g y)
```

~~ëª¨ë…¸ì´ë“œ ì¹´í…Œê³ ë¦¬(monoidal category)ì— ëŒ€í•˜ì—¬ ì´ì•¼ê¸°í–ˆë˜ê²ƒì´ ê¸°ì–µë‚©ë‹ˆê¹Œ? ëª¨ë…¸ì´ë“œ ì¹´í…Œê³ ë¦¬ëŠ” ìœ ë‹› ì˜¤ë¸Œì íŠ¸ì™€ í•¨ê»˜ ëŒ€ìƒì— ëŒ€í•œ binary operatorë¥¼ ì •ì˜í•©ë‹ˆë‹¤.  ì¼ì „ì— Setì€ ì‹±ê¸€í†¤ ì…‹ì´ unitìœ¼ë¡œ ì‘ë™í•˜ëŠ” ì¹´ë¥´í…Œì‹œì•ˆ ê³±ì—ì„œ ëª¨ë…¸ì´ë“œ ë²”ì£¼ê°€ ë©ë‹ˆë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ ì— í‹°ì…‹ì´ unitìœ¼ë¡œ ì‘ë™í•˜ëŠ” disjoint unionì—ì„œ ëª¨ë…¸ì´ë“œ ë²”ì£¼ê°€ ëœë‹¤ ì–¸ê¸‰í–ˆì—ˆìŠµë‹ˆë‹¤. ê·¸ë•Œ ì–¸ê¸‰í•˜ì§€ ì•Šì•˜ë˜ ëª¨ë…¸ì´ë“œ ì¹´í…Œê³ ë¦¬ì˜ ìš”êµ¬ì‚¬í•­ ì¤‘ í•˜ë‚˜ê°€ binary operatorê°€ bifunctorê°€ ëœë‹¤ëŠ” ê²ƒ ì…ë‹ˆë‹¤. ì´ëŠ” ë§¤ìš° ì¤‘ìš”í•©ë‹ˆë‹¤. monoidal productì´ ì‚¬ìƒì— ì˜í•´ ì •ì˜ëœ ì¹´í…Œê³ ë¦¬ì˜ êµ¬ì¡°ì™€ í˜¸í™˜ë˜ê¸°ë¥¼ ì›í•©ë‹ˆë‹¤. ì´ë¡œì¨ ëª¨ë…¸ì´ë“œ ì¹´í…Œê³ ë¦¬ì˜ ì™„ì „í•œ ì •ì˜ì— í•œë°œì§ ë” ê°€ê¹Œì›Œ ì¡ŒìŠµë‹ˆë‹¤.~~

### 8.3 Functorial Algebraic Data Types

í‘í„°ë¡œ íŒëª…ëœ ë§¤ê°œë³€ìˆ˜í™”ëœ ëª‡ê°€ì§€ íƒ€ì…ì˜ ì˜ˆë¥¼ ë³´ì•˜ìŠµë‹ˆë‹¤. ë³µì¡í•œ ë°ì´í„° íƒ€ì…ì€ ë‹¨ìˆœí•œ íƒ€ì…ì˜ ë°ì´í„°ë¡œ ë§Œë“¤ì–´ì§‘ë‹ˆë‹¤. íŠ¹ë³„íˆ ëŒ€ìˆ˜ì ì¸ ë°ì´í„° íƒ€ì…ë“¤ì€ (ADTS) sumê³¼ productì„ ì´ìš©í•˜ì—¬ ë§Œë“¤ì–´ ì§‘ë‹ˆë‹¤. sumê³¼ productì´ í‘í„°ì  ì„±ì§ˆì„ ì§€ë‹ˆëŠ”ì§€ ë³´ì•˜ê³  í‘í„°ë¥¼ í•©ì„±í•˜ëŠ”ê²ƒë„ ì••ë‹ˆë‹¤. -> **ADTSë¥¼ ë§Œë“œëŠ” ë°©ì‹ì´ í‘í„°ì ì´ë¼ëŠ” ê²ƒì„ ë³´ì•˜ê³  ì´ì œ ADTSë„ í‘í„°ì  ì„±ì§ˆì„ ì§€ë‹Œë‹¤ëŠ”ê²ƒì„ ë³¼ê²ƒì…ë‹ˆë‹¤.**

ë§¤ê°œë³€ìˆ˜í™”ëœ ADTSë¥¼ ë§Œë“œëŠ” ë‹¨ìœ„(or êµ¬ì„±ìš”ì†Œ)ëŠ” ë¬´ì—‡ì¼ê¹Œìš”? ìš°ì„  í‘í„°ì˜ íƒ€ì… ë§¤ê°œë³€ìˆ˜ì— ì˜ì¡´ì„ ì§€ë‹ˆì§€ ì•ŠëŠ” í•­ëª©ë“¤ì´ ìˆìŠµë‹ˆë‹¤: Maybeì—ì„œ Nothing, Listì—ì„œ Nil ì²˜ëŸ¼. ì´ê²ƒë“¤ì€ Const functorì™€ ë¹„ìŠ·í•©ë‹ˆë‹¤(Const functorëŠ” íƒ€ì… íŒŒë¼ë¯¸í„°ë¥¼ ë¬´ì‹œí•©ë‹ˆë‹¤)

ê·¸ë¦¬ê³ ë‚˜ì„œ ë‹¨ì§€ íƒ€ì… íŒŒë¼ë¯¸í„°ë¥¼ ìº¡ìŠí™” ì‹œí‚¤ëŠ” í•­ëª©ì´ ìˆìŠµë‹ˆë‹¤: Maybeì—ì„œì˜ Just ì²˜ëŸ¼. ì´ê²ƒë“¤ì€ Identity functorì™€ ë™ì¼í•©ë‹ˆë‹¤. ì¼ì „ì— Catì—ì„œ identity ì‚¬ìƒìœ¼ë¡œ identity functorë¥¼ ì–¸ê¸‰í–ˆì—ˆìŠµë‹ˆë‹¤. ì•„ë˜ëŠ” í•˜ìŠ¤ì¼ˆì—ì„œì˜ ì •ì˜ì…ë‹ˆë‹¤.

```haskell
data Identity a = Identity a

instance Functor Identity where
	fmap f (Identity x) = Identity (f x)
```

Identityê°€ ë¶ˆë³€í•œ ê°’ aë¥¼ ë‹¨ìˆœíˆ ì €ì¥í•˜ëŠ” ì—­í• ë§Œ í•œë‹¤ê³  ìƒê°í• ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

ëŒ€ìˆ˜ì  ë°ì´í„° êµ¬ì¡°ì—ì„œ ëª¨ë“ ê²ƒì€ ì´ ë‘ê°€ì§€ ê¸°ë³¸ ìš”ì†Œë¥¼ sumê³¼ productë¥¼ ì´ìš©í•˜ì—¬ êµ¬ì„±ë©ë‹ˆë‹¤.

```haskell
data Maybe a = Nothing | Just a
-- maybeëŠ” ë‘ íƒ€ì…ì˜ sumì…ë‹ˆë‹¤. + sumì€ í‘í„°ì  ì„±ì§ˆì„ ì§€ë‹™ë‹ˆë‹¤.
```

Maybeì—ì„œ Nothingì€ Cons ( ) a ì™€ ê°™ìŠµë‹ˆë‹¤. ë‘ë²ˆì§¸ ëŠ” ë‹¨ì§€ ë‹¤ë¥¸ ì´ë¦„ì˜ Identity functorë¡œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```haskell
type Maybe a = Either (Const () a) (Identity a)
```

MaybeëŠ” ë‘ í‘í„°( Const ( ), Identity) ì™€  ë°”ì´í‘í„° (Either)ì˜ í•©ì„±ì…ë‹ˆë‹¤.

í‘í„°ì˜ í•©ì„±ì€ í‘í„°ë¼ëŠ” ê²ƒì„ ë³´ì•˜ìŠµë‹ˆë‹¤. ë°”ì´í‘í„°ì˜ ê²½ìš°ë„ ë™ì¼í•©ë‹ˆë‹¤. ì´ì œ ì•Œì•„ë´ì•¼ í• ê²ƒì€ ì‚¬ìƒì— ëŒ€í•´ ë™ì‘í•˜ëŠ” ë‘ê°œì˜ í‘í„°ê°€ ìˆëŠ” ë°”ì´í‘í„°ì˜ í•©ì„±ì´ ì–´ë–¨ê²ƒ ì¼ê²ƒ ì´ëƒëŠ” ê²ë‹ˆë‹¤. ìš°ì„  ë‘ê°œì˜ ì‚¬ìƒì„ ê°ì ë‹¤ë¥¸ í‘í„°ë¡œ ë¦¬í”„íŒ… í•˜ê³  ê²°ê³¼ ìŒì„ ë°”ì´í‘í„°ë¥¼ ì´ìš©í•˜ì—¬ ë¦¬í”„íŒ… í•©ë‹ˆë‹¤.

ìœ„ì™€ê°™ì€ í•©ì„±ì„ í•˜ìŠ¤ì¼ˆì—ì„œ ì •ì˜í•´ ë´…ì‹œë‹¤.

```haskell
newtype BiComp bf fu gu a b = BiComp (bf (fu a) (gu b))
-- ë‘ê°œì˜ í‘í„°, fu, guì™€ ë‘ê°œì˜ íƒ€ì… a, bë¥¼ ë°›ìŒ
-- fuë¥¼ aì—, guë¥¼ bì— ì ìš©í•œ ê²°ê³¼ê°’ì„ bfë¡œ ì ìš©.
```

ìƒˆë¡œìš´ íƒ€ì… BiCompëŠ” aì™€ bì— ëŒ€í•œ ë°”ì´í‘í„° ì…ë‹ˆë‹¤.(bfê°€ ë°”ì´í‘í„°ê³  fu, guëŠ” í‘í„°). ì»´íŒŒì¼ëŸ¬ëŠ” bfì— ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” bimapì˜ ì •ì˜ê°€ ìˆìŒì„ ê·¸ë¦¬ê³  fu, guì— í•´ë‹¹í•˜ëŠ” fmapì´ ìˆìŒì„ ì•Œì•„ì•¼ í•©ë‹ˆë‹¤. í•˜ìŠ¤ì¼ˆì—ì„œ ì´ê²ƒì€ ì¸ìŠ¤í„´ìŠ¤ ì„ ì–¸ì˜ ì „ì œ ì¡°ê±´ìœ¼ë¡œ í‘œí˜„ë©ë‹ˆë‹¤.(ì´ì¤‘í™”ì‚´í‘œ ë’¤ì— í´ë˜ìŠ¤ì˜ ì œì•½ì¡°ê±´ë“¤ì„ ë‚˜ì—´)

```haskell
instance (Bifunctor bf, Functor fu, Functor gu) => 
	Bifunctor (BiComp bf fu gu) where
		bimap f1 f2 (BiComp x) = BiComp ((bimap (fmap f1) (fmap f2)) x)
```

ë°ì´í„° ìŠ¤íŠ¸ëŸ­ì²˜ì— í‘í„°ë¥¼ ì´ëŒì–´ ë‚´ëŠ”ê²ƒì€ í•˜ìŠ¤ì¼ˆì˜ íŠ¹ì • extensionì„ ì´ìš©í•˜ì—¬ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.(í‘í„° ë§ê³ ë„ ì•ì„œ ì–¸ê¸‰í•˜ì˜€ë˜ Eq íƒ€ì… í´ë˜ìŠ¤ë¥¼ í¬í•¨ë€ ì—¬ëŸ¬ ë‹¤ë¥¸ íƒ€ì… í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìœ ë„í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤. )

```haskell
{-# LANGUAGE DeriveFunctor #-}

data Maybe a = Nothing | Just a deriving Functor
```



### 8.4 Functors in ~~C++~~(Swift)

```haskell
-- Tree in haskell
data Tree a = Leaf a | Node (Tree a) (Tree a)
--	deriving Functor
	
instance Functor Tree where
	fmap f (Leaf a) = Leaf (f a)
	fmap f (Node t t') = Node (fmap f t) (fmap f t')
```

```swift
// Tree in swift
indirect enum Tree<A> {
  case leaf(A)
  case node(Tree<A>, Tree<A>)
}

func fmap<A, B>(tree: Tree<A>, function: (A) -> B) -> Tree<B> {
    switch tree {
    case let .leaf(a):
        return .leaf(function(a))
        
    case let .node(lhs, rhs):
        return .node(fmap(tree: lhs, function: function),
                     fmap(tree: rhs, function: function))
    }
}
```



### 8.5 The Writer Functor

ì¼ì „ì— ì´ì•¼ê¸°í–ˆë˜ í´ë¼ì´ìŠ¬ë¦¬ ì¹´í…Œê³ ë¦¬ì—ì„œ ì‚¬ìƒì€(Writerì„ ë¦¬í„´í•˜ëŠ”) embellishedëœ í•¨ìˆ˜ë¡œ ë‚˜íƒ€ë‚¬ì—ˆìŠµë‹ˆë‹¤.

```haskell
type Writer a = (a, String)
```

embellishmentëŠ” endofunctorì™€ ê´€ë ¨ì´ ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  ì‹¤ì œ Writeríƒ€ì… ìƒì„±ìëŠ” aì˜ í‘í„° ì…ë‹ˆë‹¤. ì´ëŠ” ë§¤ìš° ë‹¨ìˆœí•œ product íƒ€ì…ì´ê¸° ë–„ë¬¸ì— fmapì„ êµ¬í˜„í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.

í•˜ì§€ë§Œ í´ë¼ì´ìŠ¬ë¦¬ ì¹´í…Œê³ ë¦¬ì™€ í‘í„°ì™€ì˜ ì¼ë²ˆì ì¸ ê´€ê³„ëŠ” ë¬´ì—‡ì…ë‹ˆê¹Œ? í´ë¼ì´ìŠ¬ë¦¬ ì¹´í…Œê³ ë¦¬ê°€ ì¹´í…Œê³ ë¦¬ê°€ ë˜ê¸° ìœ„í•˜ì—¬ identityì™€ í•©ì„±ì„ ì•„ë˜ì™€ ê°™ì´ ì •ì˜í–ˆì—ˆìŠµë‹ˆë‹¤.

```haskell
-- í•©ì„±
(>=>) :: (a -> Writer b) -> (b -> Writer c) -> (a -> Writer c)
m1 >=> m2 = \x ->
	let (y, s1) = m1 x
			(z, s2) = m2 y
	in (z, s1 ++ s2)
	
-- identity
return :: a -> Writer a
return x = (x, "")
```

fmapì˜ ì—­í• ì„ í•  ì˜¬ë°”ë¥¸ íƒ€ì… ì‹œê·¸ë‹ˆì²˜ë¥¼ ê°€ì§„ í•¨ìˆ˜ë¥¼ ìƒì„±í•˜ê¸° ìœ„í•´ ì´ë“¤ì„ ë‹¤ìŒê³¼ ê°™ì´ ê²°í•©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```haskell
fmap f = id >=> (\x -> return (f x))
-- id í•¨ìˆ˜ì™€ ëŒë‹¤ ì•„ê·œë¨¼íŠ¸ì— ëŒ€í•˜ì—¬ fë¥¼ ì ìš©í•œ ê²°ê³¼ê°’ì„ returnì— ì ìš©í•œ í•¨ìˆ˜ë¥¼ í•©ì„±
-- idëŠ” writer aë¥¼ ë°›ì•„ writer aë¡œ ë°˜í™˜, fish ì˜¤í¼ë ˆì´í„°ëŠ” aê°’ì„ ëŒë‹¤ì˜ xë¡œ ì „ë‹¬
-- fëŠ” aë¥¼ bë¡œ ë°”ê¾¸ê³  returnìœ¼ë¡œ embellishí•˜ì—¬ Writer bë¥¼ ë§Œë“¬
-- ê²°ë¡ ì ìœ¼ë¡œ Writer aë¥¼ Writer bë¡œ ë°˜í™˜ -> fmap
```

Writerë¥¼ í™•ì¥í•˜ì—¬ ì–´ëŠíƒ€ì…ì˜ ìƒì„±ìë¡œ êµì²´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. fishì˜¤í˜ë ˆì´í„°ì™€ returnì„ ì§€ì›í•˜ëŠ”í•œ fmap ë˜í•œ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬ê¸°ë•Œë¬¸ì— í´ë¼ì´ìŠ¬ë¦¬ ì¹´í…Œê³ ë¦¬ëŠ” í•­ìƒ functor ì…ë‹ˆë‹¤.(ëª¨ë“  í‘í„°ê°€ í´ë¼ì´ìŠ¬ë¦¬ ì¹´í…Œê³ ë¦¬ë¥¼ ë°œìƒì‹œí‚¤ëŠ”ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤.)

~~deriving Functorë¥¼ í†µí•˜ì—¬ ë¶ˆëŸ¬ì˜¤ëŠ” fmapê³¼ ìœ„ì—ì„œ ì •ì˜í•œ fmapì´ ë™ì¼í•œê²ƒì¸ì§€ ê¶ê¸ˆí•´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í¥ë¯¸ë¡­ê²Œë„ ê·¸ë ‡ìŠµë‹ˆë‹¤. ì´ëŠ” í•˜ìŠ¤ì¼ˆì˜ ë‹¤í˜•ì„± í•¨ìˆ˜ë¡œ ì¸í•´ ê°€ëŠ¥í•©ë‹ˆë‹¤ ì´ë¥¼ parametric polymorphismì´ë¼ ë¶€ë¥´ê³  theorems for free ë¼ ë¶ˆë¦¬ëŠ” ê²ƒì˜ ê·¼ì›ì…ë‹ˆë‹¤. ì´ ì •ë¦¬ê°€ ë§í•˜ëŠ”ê²ƒì€ ì–´ë–¤ íƒ€ì… ìƒì„±ìì— ëŒ€í•œ fmapì˜ êµ¬í˜„ì´ ì¡´ì¬í•  ê²½ìš°ì— ê·¸ê²ƒì€ ê³ ìœ í•´ì•¼ í•œë‹¤ëŠ” ì  ì…ë‹ˆë‹¤.~~

### 8.6 Covariant and Contravariant Functors

ì´ë²ˆì—ëŠ” reader functorë¡œ ë‹¤ì‹œ ëŒì•„ê°€ ë´…ì‹œë‹¤. ë¦¬ë” í‘í„°ì—ì„œ í™”ì‚´í‘œëŠ” ë‘ë²ˆì¨° ì–´ê·œë¨¼íŠ¸ì— ëŒ€í•œ í‘í„°ì  ì„±ì§ˆì„ ì§€ë‹™ë‹ˆë‹¤.

```haskell
-- (->) a b = a -> b
-- í™”ì‚´í‘œ(->)ëŠ” a, bíƒ€ì…ì„ ë°›ëŠ” íƒ€ì… ìƒì„±ì: a -> b í˜•ì‹ì˜ í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ëƒ„
-- (-> ) rì€ íƒ€ì… ì¸ìë¥¼ í•˜ë‚˜ ë°›ì•„ì„œ ìƒˆë¡œìš´íƒ€ì…(í•¨ìˆ˜)ë¥¼ ë¦¬í„´í•˜ëŠ” íƒ€ì… ìƒì„±ì
(->) r

type Reader r a = r -> a

instance Functor (Reader r) where
	fmap f g = f . g
```

í˜ì–´ì˜ íƒ€ì… ìƒì„±ìë‚˜ Eitherì˜ íƒ€ì… ìƒì„±ìì™€ ê°™ì´ í•¨ìˆ˜ì˜ íƒ€ì… ìƒì„±ìëŠ” ë‘ê°œì˜ íƒ€ì…ì„ ì…ë ¥ë°›ìŠµë‹ˆë‹¤. í˜ì–´ë‚˜ EitherëŠ” ë‘ê°œì˜ ì–´ê·œë¨¼íŠ¸ì— ëŒ€í•˜ì—¬ í‘í„°ì  ì„±ì§ˆì„ ì§€ë‹™ë‹ˆë‹¤. - ì´ê²ƒë“¤ì€ ë°”ì´í‘í„° ì…ë‹ˆë‹¤. ê·¸ëŸ¬ë©´ ìœ„ì˜ í•¨ìˆ˜ ìƒì„±ìë„ ë°”ì´í‘í„° ì¼ê¹Œìš”?

ì²«ë²ˆì¨° ì•„ê·œë¨¼íŠ¸ rì— ëŒ€í•´ì„œ í‘í„°ë¥¼ ë§Œë“¤ì–´ ë´…ì‹œë‹¤. 

```haskell
-- ë¦¬í„´ íƒ€ì…ì˜ ì•„ê·œë¨¼íŠ¸ë¥¼ ë’¤ì§‘ì—ˆìŒ, ì´ê²½ìš°ì— ë¦¬í„´íƒ€ì… rì´ ê³ ì •ì´ê³  aíƒ€ì…ì´ ê°€ë³€ì„
type Op r a = a -> r

-- ì›ë˜ëŠ”
-- fmap :: (a -> b) -> f a -> f b
-- fê°€ (-> r)ì´ë©´
-- fmap :: (a -> b) -> (->) r a -> (->) r b
-- fmap :: (a -> b) -> (r -> a) -> (r -> b)

-- fmapì„ êµ¬í˜„í•˜ê¸° ìœ„í•´ ë‹¤ìŒê³¼ ê°™ì€ íƒ€ì… ì‹œê·¸ë‹ˆì²˜ë¥¼ ì–´ë–»ê²Œ ë§Œì¡´ì‹œí‚¬ ìˆ˜ ìˆì„ê¹Œ
fmap :: (a -> b) -> Op r a -> Op r b
fmap :: (a -> b) -> (a -> r) -> (b -> r)
```

a -> bë¡œ ê°€ëŠ” í•¨ìˆ˜ì™€ a -> rì¸ í•¨ìˆ˜ë¥¼ í•©ì³ b -> rì„ ë§Œë“¤ìˆ˜ëŠ” ì—†ë‹¤. ìµœì´ˆì˜ í™”ì‚´í‘œ a -> bë¥¼ ë’¤ì§‘ìœ¼ë©´ ìœ„ì˜ ê´€ê³„ê°€ ë§Œì¡±ë  ìˆ˜ ìˆë‹¤. ê·¸ë ‡ë‹¤ê³  ì„ì˜ì˜ í•¨ìˆ˜ë¥¼ ë’¤ì§‘ì„ ìˆ˜ ì—†ë‹¤, í•˜ì§€ë§Œ ì¹´í…Œê³ ë¦¬ë¥¼ ë’¤ì§‘ì–´ ìƒê°í•´ ë³¼ ìˆ˜ ìˆë‹¤.

(recap) ëª¨ë“  ì¹´í…Œê³ ë¦¬ Cì—ëŠ” ìŒ ì¹´í…Œê³ ë¦¬ ğ‚op ê°€ ìˆìŠµë‹ˆë‹¤. ì´ ì¹´í…Œê³ ë¦¬ì—ì„œ ëŒ€ìƒì€ Cì™€ ë™ì¼í•˜ì§€ë§Œ ì‚¬ìƒë“¤ì€ ëª¨ë‘ ë°˜ëŒ€ë°©í–¥ì…ë‹ˆë‹¤. ì´ Cop ì¹´í…Œê³ ë¦¬ì—ì„œ ë‹¤ë¥¸ ì¹´í…Œê³ ë¦¬ Dë¡œ ì´ë™í•˜ëŠ” í‘í„°ê°€ ìˆë‹¤ ê°€ì •í•´ë³´ì„¸ìš”

```haskell
F :: Cop -> D
--Copì˜ ì‚¬ìƒ fop :: a -> bë¥¼ í‘í„°ê°€ ì¹´í…Œê³ ë¦¬ Dë¡œ ë‹¤ìŒê³¼ ê°™ì´ ë§¤í•‘
-- Ffop :: F a -> F b
-- fop ì‚¬ìƒì€ ì¹´í…Œê³ ë¦¬ Cê³¼ ì—­ë°©í–¥ì´ê³  Cì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ìŒ
-- f :: b -> a
```

FëŠ” ì¼ë°˜ì ì¸ í‘í„°ì´ì§€ë§Œ Fì— ë”°ë¼ ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ë§¤í•‘ì„ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤(í‘í„°ëŠ” ì•„ë‹™ë‹ˆë‹¤). ê·¸ê²ƒì„ Gë¼ ë¶€ë¥´ê¸°ë¡œ í•©ì‹œë‹¤. GëŠ” Cì—ì„œ Dë¡œì˜ ë§¤í•‘ì„ í•©ë‹ˆë‹¤. GëŠ” Fì™€ ë™ì¼í•˜ê²Œ ëŒ€ìƒì„ ë§¤í•‘í•˜ì§€ë§Œ ì‚¬ìƒì„ ë§¤í•‘í•˜ëŠ” ê²½ìš°ì—ëŠ” ë°©í–¥ì„ ë’¤ì§‘ìŠµë‹ˆë‹¤. 

```haskell
-- ì¹´í…Œê³ ë¦¬ Cì—ì„œ f
-- f :: b -> a
Gf :: (b -> a) -> (G a -> G b)
-- Ffì˜ ê²°ê³¼ ì‚¬ìƒê³¼ ë°©í–¥ì´ ë°˜ëŒ€
```

ì´ëŠ” ë’¤í‹€ë¦° í‘í„° ì…ë‹ˆë‹¤. ì´ëŸ¬í•œ ë°©ì‹ìœ¼ë¡œ ì‚¬ìƒì„ ë’¤ì§‘ëŠ” ë²”ì£¼ ë§¤í•‘ì„ contravariant functorë¼ ë¶€ë¦…ë‹ˆë‹¤. (ì¼ë°˜ì ì¸ í‘í„°ëŠ” covirant functorë¼ ë¶€ë¦…ë‹ˆë‹¤) Contravariant functorëŠ” ë°˜ëŒ€ ì¹´í…Œê³ ë¦¬(ì›ë˜ ì¹´í…Œê³ ë¦¬)ì—ì„œëŠ” ì¼ë°˜ì ì¸ í‘í„°ì…ë‹ˆë‹¤.

![](https://bartoszmilewski.files.wordpress.com/2015/01/contravariant.jpg?w=300&h=295)

í•˜ìŠ¤ì¼ˆì—ì„œ contravariant funtorì˜ íƒ€ì…í´ë˜ìŠ¤ ì •ì˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

```haskell
class Contravariant f where
	contramap :: (b -> a) -> (f a -> f b)
	
-- ì•ì„œ ì •ì˜í•œ íƒ€ì… ìƒì„±ì OpëŠ” Contravariantì˜ ì¸ìŠ¤í„´ìŠ¤ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
instance Contravariant (Op r) where
	-- (b -> a) -> Op r a -> Op r b
	contramap f g = g . f
```

Opì— ëŒ€í•œ ì½˜íŠ¸ë¼ë§µì˜ ì •ì˜ê°€ ë‹¨ìˆœíˆ ì¸ìˆ˜ê°€ ë’¤ì§‘íŒ í•¨ìˆ˜ êµ¬ì„± ì—°ì‚°ì ì¼ ë¿ì´ë¼ëŠ” ê²ƒì„ ì•Œë©´ ìœ„ì˜ í‘œí˜„ì€ ë” ê°„ê²°í•´ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```haskell
-- ì–´ê·œë¨¼íŠ¸ë¥¼ ë’¤ì§‘ëŠ” flipì´ë¼ ë¶ˆë¦¬ëŠ” íŠ¹ë³„í•œ í•¨ìˆ˜
flip :: (a -> b -> c) -> (b -> a -> c)
flip f y x = f x y

contramap = flip(.)
```



### 8.7 Profunctors

í•¨ìˆ˜-í™”ì‚´í‘œ ì—°ì‚°ìê°€ ì²«ë²ˆì¨° ì¸ìì— ëŒ€í•´ì„œëŠ” ë°˜ë³€(contravariant) í•˜ê³  ë‘ë²ˆì¨° ì¸ìì— ëŒ€í•´ì„œëŠ” ê³µë³€(covariant) í•˜ë‹¤ëŠ” ê²ƒì„ ë³´ì•˜ìŠµë‹ˆë‹¤. ì´ëŸ° í‰ì¸¡í•œ? ê´´ë¬¼?ì„ ë­ë¼ ë¶€ë¥¼ê¹Œìš”? íƒ€ì¼“ ì¹´í…Œê³ ë¦¬ê°€ Setì¸ ê²½ìš° ì´ì™€ê°™ì€ ê´´ë¬¼ì„ profunctorë¼ í•©ë‹ˆë‹¤.

```haskell
-- íƒ€ê²Ÿ ì¹´í…Œê³ ë¦¬ê°€ Setì¸ ê²½ìš°
Cop x D -> Set
```

```haskell
class Profunctor p where
	dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
	dimap f g = lmap f . rmap g
	lmap :: (a -> b) -> p b c -> p a c
	lmap f = dimap f id
	rmap :: (b -> c) -> p a b -> p a c
	rmap = dimap id
```

ì´ì œ í•¨ìˆ˜-í™”ì‚´í‘œ ìƒì„±ìëŠ” Profunctorì˜ ì¸ìŠ¤í„´ìŠ¤ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```haskell
instance Profunctor (->) where
	dimap ab cd bc = cd . bc . ab
	lamp = flip (.)
	rmap = (.)
```



### ~~8.8 The Hom-Functor~~